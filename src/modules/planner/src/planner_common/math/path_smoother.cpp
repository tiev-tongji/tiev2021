#include "path_smoother.h"
using std::cout;
using std::endl;

namespace TiEV {

PathSmoother::PathSmoother()
    : kappaMax(0.1818),
      obsDMax(10),
      alpha(0.24915),
      wObstacle(0),
      wCurvature(1),
      wSmoothness(1),
      width(MAX_ROW),
      height(MAX_COL) {}

//###################################################
//                                SMOOTHING ALGORITHM
//###################################################
vector<Point2d> PathSmoother::smoothPath(const vector<Point2d>& path,
                                         const int              gap) {
  if (path.size() < 5) return path;
  // current number of iterations of the gradient descent smoother
  int iterations = 0;
  // the maximum iterations for the smoother
  int maxIterations = 500;
  // the lenght of the path in number of nodes
  int pathLength;
  // x_(i-2), x_(i-1), xi, x_(i+1), x_(i+2)
  Point2d xim2, xim1, xi, xip1, xip2;

  // gradient descent result is base on points from last iteration
  vector<Point2d> newPath;
  vector<Point2d> oldPath;

  // sampling every gap points
  // reason: sometimes the original_path is smooth in a small region
  // but is not smooth is a bigger region
  for (int i = 0; i + 1 < path.size(); i += gap) {
    newPath.push_back(path[i]);
  }
  newPath.push_back(path.back());
  oldPath = newPath;

  // descent along the gradient untill the maximum number of iterations has been
  // reached
  double totalWeight = wSmoothness + wCurvature + wObstacle;

  while (iterations < maxIterations) {
    for (int i = 2; i + 2 < newPath.size(); ++i) {
      xim2 = oldPath[i - 2];
      xim1 = oldPath[i - 1];
      xi   = oldPath[i];
      xip1 = oldPath[i + 1];
      xip2 = oldPath[i + 2];
      Point2d correction;

      correction =
          correction - wSmoothness * smoothnessTerm(xim2, xim1, xi, xip1, xip2);
      if (!isOnGrid(xi + correction)) {
        continue;
      }

      correction = correction - wCurvature * curvatureTerm(xim1, xi, xip1);
      if (!isOnGrid(xi + correction)) {
        continue;
      }

      xi           = xi + alpha * correction / totalWeight;
      newPath[i].x = xi.x;
      newPath[i].y = xi.y;
    }
    oldPath = newPath;
    iterations++;
  }

  vector<Point2d> interpolated_path = interpolatePath(newPath, gap - 1);

// #define VIS_INTERPOLATED_PATH
#ifdef VIS_INTERPOLATED_PATH
  cv::namedWindow("interpolated_path", cv::WINDOW_KEEPRATIO);
  cv::Mat img = cv::Mat(MAX_ROW, MAX_COL, CV_8UC3, {255, 255, 255});
  for (const auto& p : path) {
    img.at<cv::Vec3b>(lround(p.x), lround(p.y)) = cv::Vec3b(0, 255, 0);
  }
  for (const auto& p : interpolated_path) {
    img.at<cv::Vec3b>(lround(p.x), lround(p.y)) = cv::Vec3b(0, 0, 255);
  }
  cv::imshow("interpolated_path", img);
  cv::waitKey(0);
#endif

  newPath       = interpolated_path;
  oldPath       = interpolated_path;
  iterations    = 0;
  maxIterations = 100;
  while (iterations < maxIterations) {
    if (gap <= 1) break;  // didn't interpolate any point
    for (int i = 2; i + 2 < interpolated_path.size(); ++i) {
      // only process points which are generated by interpolating
      if (i % gap == 0) continue;
      xim2 = oldPath[i - 2];
      xim1 = oldPath[i - 1];
      xi   = oldPath[i];
      xip1 = oldPath[i + 1];
      xip2 = oldPath[i + 2];
      Point2d correction;

      correction =
          correction - wSmoothness * smoothnessTerm(xim2, xim1, xi, xip1, xip2);
      if (!isOnGrid(xi + correction)) {
        continue;
      }

      correction = correction - wCurvature * curvatureTerm(xim1, xi, xip1);
      if (!isOnGrid(xi + correction)) {
        continue;
      }
      xi           = xi + alpha * correction / totalWeight;
      newPath[i].x = xi.x;
      newPath[i].y = xi.y;
    }
    double cost = getTotalCost(newPath);
    oldPath     = newPath;
    iterations++;
  }

  newPath.resize(path.size());
  return newPath;
}

vector<Point2d> PathSmoother::smoothPath(
    const vector<HDMapPoint>& original_path, const int num_interpolate_points,
    std::string type) {
  vector<Point2d> path = convert2Point2d(original_path);
  vector<Point2d> interpolated_path =
      interpolatePath(path, num_interpolate_points);
  return smoothPath(interpolated_path, 1);
}

template <typename T>
vector<Point2d> PathSmoother::convert2Point2d(const vector<T>& original_path) {
  vector<Point2d> path;
  for (const auto& p : original_path) {
    path.emplace_back(p.x, p.y);
  }
  return path;
}

vector<Point2d> PathSmoother::interpolatePath(const vector<Point2d>& path,
                                              const int              n) {
  vector<Point2d> interpolated_path;
  if (path.empty() || n == 0) return path;
  Point2d p, pp, v;
  double  ratio;
  interpolated_path.reserve(path.size() * (n + 1));
  for (int i = 0; i + 1 < path.size(); ++i) {
    p  = path[i];
    pp = path[i + 1];
    v  = pp - p;
    for (double k = 0.; k < n + 1; ++k) {
      ratio = k / (n + 1);
      interpolated_path.push_back(p + ratio * v);
    }
  }
  interpolated_path.push_back(path.back());
  return interpolated_path;
}

//###################################################
//                                     CURVATURE TERM
//###################################################
Point2d PathSmoother::curvatureTerm(const Point2d& xim1, const Point2d& xi,
                                    const Point2d& xip1) {
  Point2d gradient;
  // the vectors between the nodes
  Point2d Dxi   = xi - xim1;
  Point2d Dxip1 = xip1 - xi;
  Point2d p1, p2;

  // the length of the vectors
  double absDxi   = Dxi.len();
  double absDxip1 = Dxip1.len();

  // ensure that the absolute values are not zero
  if (absDxi > 0 && absDxip1 > 0) {
    // the angular change at the node
    double Dphi = std::acos(Dxi.dot(Dxip1) / (absDxi * absDxip1));
    if (fabs(Dphi) == 1) return Point2d(0, 0);
    double kappa = Dphi / absDxi;

    // if the curvature is smaller then the maximum do nothing
    if (kappa <= kappaMax) {
      Point2d zeros(0., 0.);
      return zeros;
    } else {
      // reference: enhanced path smoothing based on conjugate
      // gradient descent for firefighting robots in petrochmical complexes
      double absDxi1Inv     = 1 / absDxi;
      double PDphi_PcosDphi = -1 / std::sqrt(1 - std::pow(std::cos(Dphi), 2));
      double u              = absDxi1Inv * PDphi_PcosDphi;
      // calculate the p1 and p2 terms
      p1        = Dxi.ort(-Dxip1) / (absDxi * absDxip1);
      p2        = (-Dxip1).ort(Dxi) / (absDxi * absDxip1);
      double  s = Dphi / (absDxi * absDxi);
      Point2d ones(1, 1);
      Point2d ki   = u * (-p1 - p2) - (s * ones);
      Point2d kim1 = u * p2 - (s * (-ones));
      Point2d kip1 = u * p1;

      // calculate the gradient
      gradient = kim1 + ki + kip1;

      if (std::isnan(gradient.x) || std::isnan(gradient.y)) {
        // std::cout << "nan values in curvature term" << std::endl;
        Point2d zeros;
        return zeros;
      } else {
        return gradient;
      }
    }
  }
  // return gradient of 0
  else {
    Point2d zeros;
    return zeros;
  }
}

//###################################################
//                                    SMOOTHNESS TERM
//###################################################
Point2d PathSmoother::smoothnessTerm(const Point2d& xim2, const Point2d& xim1,
                                     const Point2d& xi, const Point2d& xip1,
                                     const Point2d& xip2) {
  return xim2 - 4.0 * xim1 + 6.0 * xi - 4.0 * xip1 + xip2;
}

double PathSmoother::getCurvature(const Point2d& xim1, const Point2d& xi,
                                  const Point2d& xip1) {
  Point2d Dxi      = xi - xim1;
  Point2d Dxip1    = xip1 - xi;
  double  absDxi   = Dxi.len();
  double  absDxip1 = Dxip1.len();
  double  Dphi     = 0;
  if (absDxi == 0 || absDxip1 == 0)
    return 0;
  else {
    Dphi = std::acos(clamp(Dxi.dot(Dxip1) / (absDxi * absDxip1), -1., 1.));
  }
  double kappa = Dphi / absDxi / GRID_RESOLUTION;
  if (std::isnan(kappa)) {
    kappa = 0;
  }

  return kappa;
}

double PathSmoother::getTotalCost(const vector<Point2d>& path) {
  if (path.size() < 3) return 0;
  double smoothness_cost = 0;
  double obstacle_cost   = 0;
  double curvature_cost  = 0;
  double total_cost;
  for (int i = 1; i + 1 < path.size(); ++i) {
    Point2d Dxip1 = path[i + 1] - path[i];
    Point2d Dxi   = path[i] - path[i - 1];
    smoothness_cost += (Dxip1 - Dxi).sqrLen();
    curvature_cost += getCurvature(path[i - 1], path[i], path[i + 1]);
  }
  total_cost = smoothness_cost + obstacle_cost + curvature_cost;
  // cout << "total cost: " << total_cost << ", smooth: " << smoothness_cost
  //      << ", curvature: " << curvature_cost << endl;
  return total_cost;
}

template <class T>
T PathSmoother::clamp(const T& value, const T& lb, const T& ub) {
  if (value >= ub) return ub;
  if (value <= lb) return lb;
  return value;
}

}  // namespace TiEV